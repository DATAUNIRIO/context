--- 
title: "Poverty and Inequality with Complex Survey Data"
author: "Guilherme Jacob, Anthony Damico, and Djalma Pessoa"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site

output:
  bookdown::tufte_html_book:
    toc: yes
    css: toc.css
  bookdown::pdf_book:
    includes:
      in_header: preamble.tex
    latex_engine: xelatex
    citation_package: natbib
    keep_tex: yes
  bookdown::epub_book: default

    
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
github-repo: guilhermejacob/context
description: "A book about the R convey package"
---

# Introduction

The R `convey` library estimates measures of poverty, inequality, and wellbeing.  There are two other R libraries covering this subject, [vardpoor](https://CRAN.R-project.org/package=vardpoor) and [laeken](https://CRAN.R-project.org/package=laeken), however, only `convey` integrates seamlessly with the [R survey package](https://CRAN.R-project.org/package=survey).

`convey` is free and open-source software that runs inside the [R environment for statistical computing](https://www.r-project.org/).  Anyone can review and propose changes to [the source code](https://github.com/DjalmaPessoa/convey) for this software.  Readers are welcome to [propose changes to this book](https://github.com/guilhermejacob/context/) as well.

## Installation {#install}

In order to work with the `convey` library, you will need to have R running on your machine.  If you have never used R before, you will need to [install that software](https://www.r-project.org/) before `convey` can be accessed.  Check out [FlowingData](http://flowingdata.com/2012/06/04/resources-for-getting-started-with-r/) for a concise list of resources for new R users.  Once you have R loaded on your machine, you can install..


* the latest released version from [CRAN](https://CRAN.R-project.org/package=convey) with

    ```R
    install.packages("convey")
    ````

* the latest development version from github with

    ```R
    devtools::install_github("djalmapessoa/convey")
    ```



## Complex surveys and statistical inference {#survey}

In this book, we demonstrate how to measure poverty and income concentration in a population based on microdata collected from a complex survey sample.  Most surveys administered by government agencies or larger research organizations utilize a sampling design that violates the assumption of simple random sampling (SRS), including:

1. Different units selection probabilities;
2. Clustering of units;
3. Stratification of clusters;
4. Reweighting to compensate for missing values and other adjustments.

Therefore, basic unweighted R commands such as `mean()` or `glm()` will not properly account for the weighting nor the measures of uncertainty (such as the confidence intervals) present in the dataset.  For some examples of publicly-available complex survey data sets, see [http://asdfree.com]().  

Unlike other software, the R `convey` package does not require that the user specify these parameters throughout the analysis.  So long as the [svydesign object](http://r-survey.r-forge.r-project.org/survey/html/svydesign.html) or [svrepdesign object](http://r-survey.r-forge.r-project.org/survey/html/svrepdesign.html) has been constructed properly at the outset of the analysis, the `convey` package will incorporate the survey design automatically and produce statistics and variances that take the complex sample into account.


## Usage Examples


In the following example, we've loaded the data set `eusilc` from the R libraries [vardpoor](https://CRAN.R-project.org/package=vardpoor) and [laeken](https://CRAN.R-project.org/package=laeken).

```{r results='hide', message=FALSE, warning=FALSE}
library(vardpoor)
data(eusilc)
```
Next, we create an object of class `survey.design` using the function `svydesign` of the library survey:

```{r results='hide', message=FALSE, warning=FALSE}
library(survey)
des_eusilc <- svydesign(ids = ~rb030, strata =~db040,  weights = ~rb050, data = eusilc)
```
Right after the creation of the design object `des_eusilc`, we should use the function `convey_prep` that adds an attribute to the survey design which saves information on the design object based upon the whole sample, needed to work with subset designs.

```{r}
library(convey)
des_eusilc <- convey_prep( des_eusilc )
```
To estimate the at-risk-of-poverty rate, we use the function `svyarpt`:

```{r comment=NA}
svyarpr(~eqIncome, design=des_eusilc)
```
To estimate the at-risk-of-poverty rate across domains defined by the variable `db040` we use:

```{r comment=NA}
svyby(~eqIncome, by = ~db040, design = des_eusilc, FUN = svyarpr, deff = FALSE)
```

Using the same data set, we estimate the quintile share ratio: 

```{r comment=NA}
# for the whole population
svyqsr(~eqIncome, design=des_eusilc, alpha= .20)

# for domains
svyby(~eqIncome, by = ~db040, design = des_eusilc,
  FUN = svyqsr, alpha= .20, deff = FALSE)

```

These functions can be used as S3 methods for the classes `survey.design` and `svyrep.design`.

Let's create a design object of class `svyrep.design` and run the function `convey_prep` on it:

```{r}
des_eusilc_rep <- as.svrepdesign(des_eusilc, type = "bootstrap")
des_eusilc_rep <- convey_prep(des_eusilc_rep) 
```

and then use the function `svyarpr`:

```{r comment=NA}
svyarpr(~eqIncome, design=des_eusilc_rep)

svyby(~eqIncome, by = ~db040, design = des_eusilc_rep, FUN = svyarpr, deff = FALSE)
```
The functions of the library convey are called in a similar way  to the functions in library survey.

It is also possible to deal with missing values by using the argument `na.rm`.

```{r comment=NA}
# survey.design using a variable with missings
svygini( ~ py010n , design = des_eusilc )
svygini( ~ py010n , design = des_eusilc , na.rm = TRUE )

# svyrep.design using a variable with missings
svygini( ~ py010n , design = des_eusilc_rep )
svygini( ~ py010n , design = des_eusilc_rep , na.rm = TRUE )
```



djalmapessoa_look, where do these references go on this page?  [@berger2003] and [@osier2009] and [@deville1999]



## Underlying Calculations


djalmapessoa_look, please describe the general purpose of linearization


In the `convey` library, there are some basic functions that produce the linearized variables needed to measure income concentration and poverty.  For example, looking at the income variable in some complex survey dataset, the `quantile` of that income variable can be linearized by the function `convey::svyiqalpha` and the sum total below any quantile of the variable is linearized by the function `convey::svyisq`.

From the linearized variables of these basic estimates, it is possible by using rules of composition, valid for influence functions, to derive the influence function of more complex estimates. By definition the influence function is a Gateaux derivative and the rules rules of composition valid for Gateaux derivatives also hold for Influence Functions.

The following property of Gateaux derivatives was often used in the library convey. Let $g$ be a differentiable function of $m$ variables. Suppose we want to compute the influence function of the estimator $g(T_1, T_2,\ldots, T_m)$, knowing the Influence function of the estimators $T_i, i=1,\ldots, m$. Then the following holds:

$$
I(g(T_1, T_2,\ldots, T_m)) = \sum_{i=1}^m \frac{\partial g}{\partial T_i}I(T_i)
$$

In the library convey this rule is implemented by the function `contrastinf` which uses the R function `deriv` to compute the formal partial derivatives $\frac{\partial g}{\partial T_i}$. 

For example, suppose we want to linearize the `Relative median poverty gap`(rmpg), defined as the difference between the at-risk-of-poverty threshold (`arpt`) and the median of incomes less than the `arpt` relative to the `arprt`: 

$$
rmpg= \frac{arpt-medpoor} {arpt}
$$

where `medpoor` is the median of incomes less than `arpt`.

Suppose we know how to linearize `arpt` and `medpoor`, then by applying the function `contrastinf` with 
$$
g(T_1,T_2)= \frac{(T_1 - T_2)}{T_1}
$$
we linearize the `rmpg`.



## The Variance Estimator


djalmapessoa_look please add references to this section


The variance of the estimator $T(\hat{M})$ can approximated by:

$$Var\left[T(\hat{M})\right]\cong var\left[\sum_s w_i z_i\right]$$

The  `linearized` variable $z$  is given by the derivative of the functional:

$$
z_k=lim_{t\rightarrow0}\frac{T(M+t\delta_k)-T(M)}{t}=IT_k(M)
$$

where, $\delta_k$ is the Dirac measure in $k$: $\delta_k(i)=1$ if and only if $i=k$.

This **derivative** is called  **Influence Function** and was introduced in the area of **Robust Statistics**.



## Influence Functions

Some measures of poverty and income concentration are defined by non-differentiable functions so that it is not possible to use Taylor linearization to estimate their variances. An alternative is to use **Influence functions** as described in [@deville1999] and [@osier2009]. The convey library implements this methodology to work with `survey.design` objects and also with `svyrep.design` objects.

Some examples of these measures are:

- At-risk-of-poverty threshold:
$arpt=.60q_{.50}$ where $q_{.50}$ is the income median;

- At-risk-of-poverty rate
$arpr=\frac{\sum_U 1(y_i \leq arpt)}{N}.100$

- Quintile share ratio
     
$qsr=\frac{\sum_U 1(y_i>q_{.80})}{\sum_U 1(y_i\leq q_{.20})}$

- Gini coefficient
$1+G=\frac{2\sum_U (r_i-1)y_i}{N\sum_Uy_i}$
where $r_i$ is the rank of $y_i$.

Note that it is not possible to use Taylor linearization for these measures because they depend on quantiles and the Gini is defined as a function of ranks. This could be done using the approach proposed by Deville (1999) based upon influence functions. 



Let $U$ be a population of size $N$ and $M$ be a measure that allocates mass one to the set composed by one unit, that is $M(i)=M_i= 1$ if $i\in U$ and $M(i)=0$ if $i\notin U$ 

Now, a population parameter $\theta$ can be expressed as a functional of $M$
$\theta=T(M)$

Examples of such parameters are:

- Total: 
$Y=\sum_Uy_i=\sum_U y_iM_i=\int ydM=T(M)$

- Ratio of two totals:
$R=\frac{Y}{X}=\frac{\int y dM}{\int x dM}=T(M)$

- Cumulative distribution function:
$F(x)=\frac{\sum_U 1(y_i\leq x)}{N}=\frac{\int 1(y\leq x)dM}{\int{dM}}=T(M)$


To estimate these parameters from the sample, we replace the measure $M$ by the estimated measure $\hat{M}$ defined by: $\hat{M}(i)=\hat{M}_i= w_i$ if $i\in s$ and $\hat{M}(i)=0$ if $i\notin s$. 

The estimators of the population parameters can then be expressed as functional of the measure  $\hat{M}$. 

-  Total:
$\hat{Y}=T(\hat{M})=\int yd\hat{M}=\sum_s w_iy_i$

- Ratio of totals:
$\hat{R}=T(\hat{M})=\frac{\int y d\hat{M}}{\int x d\hat{M}}=\frac{\sum_s w_iy_i}{\sum_s w_ix_i}$

- Cumulative distribution function:
$\hat{F}(x)=T(\hat{M})=\frac{\int 1(y\leq x)d\hat{M}}{\int{d\hat{M}}}=\frac{\sum_s w_i 1(y_i\leq x)}{\sum_s w_i}$



## Influence Function Examples


- Total:
$$
\begin{aligned}
IT_k(M)&=lim_{t\rightarrow 0}\frac{T(M+t\delta_k)-T(M)}{t}\\
&=lim_{t\rightarrow 0}\frac{\int y.d(M+t\delta_k)-\int y.dM}{t}\\
&=lim_{t\rightarrow 0}\frac{\int yd(t\delta_k)}{t}=y_k	
\end{aligned}
$$


- Ratio of two totals:
$$
\begin{aligned}
IR_k(M)&=I\left(\frac{U}{V}\right)_k(M)=\frac{V(M)\times IU_k(M)-U(M)\times IV_k(M)}{V(M)^2}\\
&=\frac{X y_k-Y x_k}{X^2}=\frac{1}{X}(y_k-Rx_k)
\end{aligned}
$$

## Examples of Linearization Using the Influence Function

- At-risk-of-poverty threshold:
$$
arpt = 0.6\times m
$$
where $m$ is the median income.

$$
z_k= -\frac{0.6}{f(m)}\times\frac{1}{N}\times\left[I(y_k\leq m-0.5) \right]
$$


- At-risk-of-poverty rate:

\[
 arpr=\frac{\sum_U I(y_i \leq t)}{\sum_U w_i}.100
\]
\[
z_k=\frac{1}{N}\left[I(y_k\leq t)-t\right]-\frac{0.6}{N}\times\frac{f(t)}{f(m)}\left[I(y_k\leq m)-0.5\right]
\]

where:

$N$ - population size; 

$t$ - at-risk-of-poverty threshold;

$y_k$ - income of person $k$;

$m$ - median income;

$f$ - income density function;


## Replication Designs

djalmapessoa_look, please describe how the software works differently on svrepdesign objects -- as compared to svydesign objects

## Decomposition

Some inequality and multidimensional poverty measures can be decomposed. As of December 2016, the decomposition methods in `convey` are limited to group decomposition.

For instance, the generalized entropy index can be decomposed into between and within group components. This sheds light on a very simple question: of the overall inequality, how much can be explained by inequalities between groups and within groups? Since this measure is additive decomposable, one can get estimates of the coefficients, SEs and covariance between components. For a more practical approach, see [@lima2013].

The Alkire-Foster class of multidimensional poverty indices can be decomposed by dimension and groups. This shows how much each group (or dimension) contribute to the overall poverty.

This technique can help understand where and who is more affected by inequality and poverty, contributing to more specific policy and economic analysis.

<!--chapter:end:index.Rmd-->

# Poverty Indices  {#poverty}

## At Risk of Poverty Ratio (svyarpr)


For additional usage examples of `svyarpr`, type `?convey::svyarpr` in the R console.


here are the references

[@osier2009] and [@deville1999]



## At Risk of Poverty Threshold (svyarpt)



For additional usage examples of `svyarpt`, type `?convey::svyarpt` in the R console.


here are the references

[@osier2009] and [@deville1999]



## Relative Median Income Ratio (svyrmir)


For additional usage examples of `svyrmir`, type `?convey::svyrmir` in the R console.


here are the references

[@osier2009] and [@deville1999]



## Relative Median Poverty Gap (svyrmpg)



For additional usage examples of `svyrmpg`, type `?convey::svyrmpg` in the R console.


here are the references

[@osier2009] and [@deville1999]


## Median Income Below the At Risk of Poverty Threshold  (svypoormed)


For additional usage examples of `svypoormed`, type `?convey::svypoormed` in the R console.


here are the references

[@osier2009] and [@deville1999]



## Foster-Greer-Thorbecke class (svyfgt)



[@foster1984] proposed a family of indicators to measure poverty.  This class of $FGT$ measures, can be defined as

\[
p=\frac{1}{N}\sum_{k\in U}h(y_{k},\theta ), 
\]

where

\[
h(y_{k},\theta )=\left[ \frac{(\theta -y_{k})}{\theta }\right] ^{\gamma
}\delta \left\{ y_{k}\leq \theta \right\} , 
\]

where: $\theta$ is the poverty threshold; $\delta$ the indicator function that assigns value $1$ if the condition $\{y_{k}\leq \theta \}$ is satisfied and $0$ otherwise, and $\gamma$ is a non-negative constant. 

When $\gamma =0$, $p$ can be interpreted as the poverty headcount ratio, and for $\gamma \geq 1$, the weight of the income shortfall of the poor to a power $\gamma$, (Foster and all, 1984).

The poverty measure FGT is implemented in the library convey by the function `svyfgt`.
The argument `thresh_type` of this function defines the type of poverty threshold adopted.
There are three possible choices:

1. `abs` -- fixed and given by the argument thresh_value
2. `relq` -- a proportion of a quantile fixed by the argument `proportion` and the quantile is defined by the argument `order`.
3. `relm` -- a proportion of the mean fixed the argument `proportion`

The quantile and the mean involved in the definition of the threshold are estimated for the whole population. When $\gamma=0$ and $\theta= .6*MED$ the measure is equal to the indicator `arpr` computed by
the function  `svyarpr`. 

Next, we give some examples of the function `svyfgt` to estimate the values of the FGT poverty index.

Consider first the poverty threshold fixed ($\gamma=0$) in the value $10000$. The headcount ratio (FGT0) is

```{r comment=NA}
svyfgt(~eqIncome, des_eusilc, g=0, abs_thresh=10000)
```

The poverty gap (FGT1) ($\gamma=1$) index for the poverty threshold fixed at the same value is

```{r comment=NA}
svyfgt(~eqIncome, des_eusilc, g=1, abs_thresh=10000)
```

To estimate the FGT0 with the poverty threshold fixed at $0.6* MED$ we fix the argument type_thresh="relq" and use the default values for  `percent`  and   `order`:

```{r comment=NA}
svyfgt(~eqIncome, des_eusilc, g=0, type_thresh= "relq")
```
that matches the estimate obtained by

```{r comment=NA}
svyarpr(~eqIncome, design=des_eusilc, .5, .6)
```
To estimate the poverty gap(FGT1) with the poverty threshold equal to $0.6*MEAN$
we use:

```{r comment=NA}
svyfgt(~eqIncome, des_eusilc, g=1, type_thresh= "relm")
```


---

**A replication example**

In July 2006, [@jenkins2006] presented at the North American Stata Users' Group Meetings on the stata Atkinson Index command.  The example below reproduces those statistics.

In order to match the results in [@jenkins2006] using the function `svyfgt` from the library convey, the poverty threshold was considered fixed, when in fact was estimated from the sample. This amounts to taking the variance of the estimated poverty threshold as zero, and not considering it when estimating the error of the FGT measure estimate. It is possible, using the function `svyfgt`, to work with an estimated poverty threshold by  appropriatelly choosing  the argument `type_thresh`.

Load and prepare the same data set:
```{r}
# load the convey package
library(convey)

# load the survey library
library(survey)

# load the foreign library
library(foreign)

# create a temporary file on the local disk
tf <- tempfile()

# store the location of the presentation file
presentation_zip <- "http://repec.org/nasug2006/nasug2006_jenkins.zip"

# download jenkins' presentation to the temporary file
download.file( presentation_zip , tf , mode = 'wb' )

# unzip the contents of the archive
presentation_files <- unzip( tf , exdir = tempdir() )

# load the institute for fiscal studies' 1981, 1985, and 1991 data.frame objects
x81 <- read.dta( grep( "ifs81" , presentation_files , value = TRUE ) )
x85 <- read.dta( grep( "ifs85" , presentation_files , value = TRUE ) )
x91 <- read.dta( grep( "ifs91" , presentation_files , value = TRUE ) )

# NOTE: we recommend using ?convey::svyarpt rather than this unweighted calculation #

# calculate 60% of the unweighted median income in 1981
unwtd_arpt81 <- quantile( x81$eybhc0 , 0.5 ) * .6

# calculate 60% of the unweighted median income in 1985
unwtd_arpt85 <- quantile( x85$eybhc0 , 0.5 ) * .6

# calculate 60% of the unweighted median income in 1991
unwtd_arpt91 <- quantile( x91$eybhc0 , 0.5 ) * .6

# stack each of these three years of data into a single data.frame
x <- rbind( x81 , x85 , x91 )
```

Replicate the author's survey design statement from stata code..
```{code}
. ge poor = (year==1981)*(x < $z_81) + (year==1985)*(x < $z_85) +  (year==1991)*(x < $z_91)
. * account for clustering within HHs 
. svyset hrn [pweight = wgt]
```

.. into R code:


```{r}
# initiate a linearized survey design object
y <- svydesign( ~ hrn , data = x , weights = ~ wgt )

# immediately run the `convey_prep` function on the survey design
z <- convey_prep( y )
```

Replicate the author's headcount ratio results with stata..
```{code}
. svy: mean poor if year == 1981
(running mean on estimation sample)

Survey: Mean estimation

Number of strata =       1          Number of obs    =    9772
Number of PSUs   =    7476          Population size  = 5.5e+07
                                    Design df        =    7475

--------------------------------------------------------------
             |             Linearized
             |       Mean   Std. Err.     [95% Conf. Interval]
-------------+------------------------------------------------
        poor |   .1410125   .0044859       .132219     .149806
--------------------------------------------------------------

. svy: mean poor if year == 1985
(running mean on estimation sample)

Survey: Mean estimation

Number of strata =       1          Number of obs    =    8991
Number of PSUs   =    6972          Population size  = 5.5e+07
                                    Design df        =    6971

--------------------------------------------------------------
             |             Linearized
             |       Mean   Std. Err.     [95% Conf. Interval]
-------------+------------------------------------------------
        poor |    .137645   .0046531      .1285235    .1467665
--------------------------------------------------------------

. svy: mean poor if year == 1991
(running mean on estimation sample)

Survey: Mean estimation

Number of strata =       1          Number of obs    =    6468
Number of PSUs   =    5254          Population size  = 5.6e+07
                                    Design df        =    5253

--------------------------------------------------------------
             |             Linearized
             |       Mean   Std. Err.     [95% Conf. Interval]
-------------+------------------------------------------------
        poor |   .2021312   .0062077      .1899615    .2143009
--------------------------------------------------------------
```

..using R code:

```{r}
headcount_81 <- 
	svyfgt( 
		~ eybhc0 , 
		subset( z , year == 1981 ) , 
		g = 0 , 
		abs_thresh = unwtd_arpt81
	)

headcount_81

confint( headcount_81 , df = degf( subset( z , year == 1981 ) ) )

headcount_85 <- 
	svyfgt( 
		~ eybhc0 , 
		subset( z , year == 1985 ) , 
		g = 0 , 
		abs_thresh = unwtd_arpt85 
	)
	
headcount_85

confint( headcount_85 , df = degf( subset( z , year == 1985 ) ) )

headcount_91 <- 
	svyfgt( 
		~ eybhc0 , 
		subset( z , year == 1991 ) , 
		g = 0 , 
		abs_thresh = unwtd_arpt91 
	)

headcount_91
	
confint( headcount_91 , df = degf( subset( z , year == 1991 ) ) )
```



Confirm this replication applies for the normalized poverty gap as well, comparing stata code..
```{code}
. ge ngap = poor*($z_81- x)/$z_81 if year == 1981

. svy: mean ngap if year == 1981
(running mean on estimation sample)

Survey: Mean estimation

Number of strata =       1          Number of obs    =    9772
Number of PSUs   =    7476          Population size  = 5.5e+07
                                    Design df        =    7475

--------------------------------------------------------------
             |             Linearized
             |       Mean   Std. Err.     [95% Conf. Interval]
-------------+------------------------------------------------
        ngap |   .0271577   .0013502      .0245109    .0298044
--------------------------------------------------------------
```

..to R code:

```{r}
norm_pov_81 <- 
	svyfgt( 
		~ eybhc0 , 
		subset( z , year == 1981 ) , 
		g = 1 , 
		abs_thresh = unwtd_arpt81
	)
	
norm_pov_81

confint( norm_pov_81 , df = degf( subset( z , year == 1981 ) ) )
```





For additional usage examples of `svyfgt`, type `?convey::svyfgt` in the R console.

here are the references

[@foster1984] and [@berger2003]



<!--chapter:end:01-poverty.Rmd-->

# Inequality Measurement {#inequality}

Another problem faced by societies is inequality. Economic inequality can have several different meanings: income, education, resources, opportunities, wellbeing, etc. Usually, studies on economic inequality focus on income distribution.

Most inequality data comes from censuses and household surveys. Therefore, in order to produce reliable estimates from this samples, appropriate procedures are necessary.

This chapter presents brief presentations on inequality measures, also providing replication examples if possible. It starts with the Lorenz curve and inequality measures derived from it, then the concept of entropy and measures based on it are presented.

## Lorenz Curve (svylorenz)

Though not an inequality measure in itself, the Lorenz curve is a classic instrument of distribution analysis. Basically, it is a function that associates a cumulative share of the population to the share of the total income it owns. In mathematical terms, 

\[
L(p) = \frac{\int_{-\infty}^{Q_p}yf(y)dy}{\int_{-\infty}^{+\infty}yf(y)dy}
\]

where $Q_p$ is the quantile $p$ of the population.

The two extreme distributive cases are 

- Perfect equality:
    - Every individual has the same income;
    - Every share of the population has the same share of the income;
    - Therefore, the reference curve is \[L(p) = p \text{ } \forall p \in [0,1] \text{.}\]
- Perfect inequality:
    - One individual concentrates all of society's income, while the other individuals have zero income;
    - Therefore, the reference curve is 
    
\[
L(p)=
\begin{cases}
0, &\forall p < 1 \\
1, &\text{if } p = 1 \text{.}
\end{cases}
\]
    
In order to evaluate the degree of inequality in a society, the analyst looks at the distance between the real curve and those two reference curves.

The estimator of this function was derived by [@kovacevic1997]:

\[
L(p) = \frac{ \sum_{i \in S} w_i \cdot y_i \cdot \delta \{ y_i \le \widehat{Q}_p \}}{\widehat{Y}}, \text{ } 0 \le p \le 1.
\]

Yet, this formula is used to calculate specific points of the curve and their respective SEs. The formula to plot an approximation of the continuous empirical curve comes from [@lerman1989].

---

**A replication example**

In October 2016, [@jann2016] released a pre-publication working paper to estimate lorenz and concentration curves using stata.  The example below reproduces the statistics presented in his section 4.1.

```{r}
# load the convey package
library(convey)

# load the survey library
library(survey)

# load the stata-style webuse library
library(webuse)

# load the NLSW 1988 data
webuse("nlsw88")

# coerce that `tbl_df` to a standard R `data.frame`
nlsw88 <- data.frame( nlsw88 )

# initiate a linearized survey design object
des_nlsw88 <- svydesign( ids = ~1 , data = nlsw88 )

# immediately run the `convey_prep` function on the survey design
des_nlsw88 <- convey_prep(des_nlsw88)

# estimates lorenz curve
result.lin <- svylorenz( ~wage, des_nlsw88, quantiles = seq( 0, 1, .05 ), na.rm = T )


# note: most survey commands in R use Inf degrees of freedom by default
# stata generally uses the degrees of freedom of the survey design.
# therefore, while this extended syntax serves to prove a precise replication of stata
# it is generally not necessary.
section_four_one <-
	data.frame( 
		estimate = coef( result.lin ) , 
		standard_error = SE( result.lin ) , 
		ci_lower_bound = 
		    coef( result.lin ) + 
		    SE( result.lin ) * 
		    qt( 0.025 , degf( subset( des_nlsw88 , !is.na( wage ) ) ) ) ,
		ci_upper_bound = 
		    coef( result.lin ) + 
		    SE( result.lin ) * 
		    qt( 0.975 , degf( subset( des_nlsw88 , !is.na( wage ) ) ) )
	)
	

knitr::kable(
  section_four_one , caption = 'Here is a nice table!',
  booktabs = TRUE
)
```


For additional usage examples of `svylorenz`, type `?convey::svylorenz` in the R console.


## Gini index (svygini)

The Gini index is an attempt to express the inequality presented in the Lorenz curve as a single number. In essence, it is twice the area between the equality curve and the real Lorenz curve. Put simply:

\[
\begin{aligned}
G &= 2 \bigg( \int_{0}^{1} pdp - \int_{0}^{1} L(p)dp \bigg) \\
\therefore G &= 1 - 2 \int_{0}^{1} L(p)dp
\end{aligned}
\]

where $G=0$ in case of perfect equality and $G = 1$ in the case of perfect inequality.

The estimator proposed by [@osier2009] is defined as:

\[
\widehat{G} = \frac{ 2 \sum_{i \in S} w_i r_i y_i - \sum_{i \in S} w_i y_i }{ \hat{Y} }
\]

The linearized formula of $\widehat{G}$ is used to calculate the SE.



---

**A replication example**

The R `vardpoor` package [@vardpoor], created by researchers at the Central Statistical Bureau of Latvia, includes a gini coefficient calculation using the ultimate cluster method.  The example below reproduces those statistics.

Load and prepare the same data set:

```{r}
# load the convey package
library(convey)

# load the survey library
library(survey)

# load the vardpoor library
library(vardpoor)

# load the synthetic european union statistics on income & living conditions
data(eusilc)

# make all column names lowercase
names( eusilc ) <- tolower( names( eusilc ) )

# add a column with the row number
dati <- data.table(IDd = 1 : nrow(eusilc), eusilc)

# calculate the gini coefficient
# using the R vardpoor library
varpoord_gini_calculation <-
	varpoord(
	
		# analysis variable
		Y = "eqincome", 
		
		# weights variable
		w_final = "rb050",
		
		# row number variable
		ID_level1 = "IDd",
		
		# strata variable
		H = "db040", 
		
		N_h = NULL ,
		
		# clustering variable
		PSU = "rb030", 
		
		# data.table
		dataset = dati, 
		
		# gini coefficient function
		type = "lingini"
		
	)

# all calculations produced by vardpoor::lingini
varpoord_gini_calculation$all_result

# construct a survey.design
# using our recommended setup
des_eusilc <- 
	svydesign( 
		ids = ~ rb030 , 
		strata = ~ db040 ,  
		weights = ~ rb050 , 
		data = eusilc
	)

# immediately run the convey_prep function on it
des_eusilc <- convey_prep( des_eusilc )

# coefficients do match
varpoord_gini_calculation$all_result$value
coef( svygini( ~ eqincome , des_eusilc ) ) * 100

# variances do not match exactly
attr( svygini( ~ eqincome , des_eusilc ) , 'var' ) * 10000
varpoord_gini_calculation$all_result$var

# standard errors do not match exactly
varpoord_gini_calculation$all_result$se
SE( svygini( ~ eqincome , des_eusilc ) ) * 100
```

By default, the `convey::svygini` function comes close to the results of `vardpoor::lingini`.  However, the measures of uncertainty do not line up, because `library(vardpoor)` defaults to the ultimate cluster method.  This can be replicated with an alternative setup of the `survey.design` object.  The ultimate cluster method is marginally less conservative, therefore, we do not recommend using it as the default.

```{r}
# within each strata, sum up the weights
cluster_sums <- aggregate( eusilc$rb050 , list( eusilc$db040 ) , sum )

# name the within-strata sums of weights the `cluster_sum`
names( cluster_sums ) <- c( "db040" , "cluster_sum" )

# merge this column back onto the data.frame
eusilc <- merge( eusilc , cluster_sums )

# construct a survey.design
# with the fpc using the cluster sum
des_eusilc_ultimate_cluster <- 
	svydesign( 
		ids = ~ rb030 , 
		strata = ~ db040 ,  
		weights = ~ rb050 , 
		data = eusilc , 
		fpc = ~ cluster_sum 
	)

# again, immediately run the convey_prep function on the `survey.design`
des_eusilc_ultimate_cluster <- convey_prep( des_eusilc_ultimate_cluster )

# matches
attr( svygini( ~ eqincome , des_eusilc_ultimate_cluster ) , 'var' ) * 10000
varpoord_gini_calculation$all_result$var

# matches
varpoord_gini_calculation$all_result$se
SE( svygini( ~ eqincome , des_eusilc_ultimate_cluster ) ) * 100
```


For additional usage examples of `svygini`, type `?convey::svygini` in the R console.


## Amato index (svyamato)

The Amato index is also based on the Lorenz curve, but instead of focusing on the area of the curve, it focuses on its length. [@arnold2012] proposes a formula not directly based in the Lorenz curve, which [@barabesi2016] uses to present the following estimator:

\[
\widehat{A} = \sum_{i \in S} w_i \bigg[ \frac{1}{\widehat{N}^2} + \frac{y_i^2}{\widehat{Y}^2} \bigg]^{\frac{1}{2}} \text{,}
\]

which also generates the linearized formula for SE estimation.

The minimum value $A$ assumes is $\sqrt{2}$ and the maximum is $2$. In order to get a measure in the interval $[0,1]$, the standardized Amato index $\widetilde{A}$ can be defined as:

\[
\widetilde{A} = \frac{ A - \sqrt{2} }{2 - \sqrt{2} } \text{ .}
\]


For additional usage examples of `svyamato`, type `?convey::svyamato` in the R console.


## Zenga Index and Curve (svyzenga, svyzengacurve)

The Zenga index and its curve were proposed in [@zenga2007]. As [@polisicchio2011] noticed, this curve derives directly from the Lorenz curve, and can be defined as:

\[
Z(p) = 1 - \frac{L(p)}{p} \cdot \frac{1 - p}{1 - L(p)}.
\]

In the `convey` library, an experimental estimator based on the Lorenz curve is used:

\[
\widehat{Z(p)} = \frac{ p \widehat{Y} - \widehat{\widetilde{Y}}(p) }{p \big[ \widehat{Y} - \widehat{\widetilde{Y}}(p) \big] }.
\]

In turn, the Zenga index derives from this curve and is defined as:

\[
Z = \int_0^1 Z(p)dp.
\]

However, its estimators were proposed by [@langel2012] and [@barabesi2016]. In this library, the latter is used and is defined as:

\[
\widehat{Z} = 1 - \sum_{i \in S} w_i \bigg[ \frac{ ( \widehat{N} - \widehat{H}_{y_i} ) ( \widehat{Y} -\widehat{K}_{y_i} ) }
{ \widehat{N} \cdot \widehat{H}_{y_i} \cdot \widehat{K}_{y_i} } \bigg]
\]

where $\widehat{N}$ is the population total, $\widehat{Y}$ is the total income, $\widehat{H}_{y_i}$ is the sum of incomes below or equal to $y_i$ and $\widehat{N}_{y_i}$ is the sum of incomes greater or equal to $y_i$.



For additional usage examples of `svyzenga` or `svyzengacurve`, type `?convey::svyzenga` or `?convey::svyzengacurve` in the R console.

## Entropy-based Measures

Entropy is a concept derived from information theory, meaning the expected amount of information given the occurrence of an event. Following [@shannon1948], given an event $y$ with probability density function $f(\cdot)$, the information content given the occurrence of $y$ can be defined as $g(f(y)) \colon= - \log f(y)$. Therefore, the expected information or, put simply, the *entropy* is

\[
H(f) \colon = -E \big[ \log f(y) \big] = - \int_{-\infty}^{\infty} f(y) \log f(y) dy
\]

Assuming a discrete distribution, with $p_k$ as the probability of occurring event $k \in K$, the entropy formula takes the form:

\[
H = - \sum_{k \in K} p_k \log p_k \text{.}
\]

The main idea behind it is that the expected amount of information of an event is inversely proportional to the probability of its occurrence. In other words, the information derived from the observation of a rare event is higher than of the information of more probable events.

Using the intuition presented in [@cowell2009], substituting the density function by the income share of an individual $s(q) = {F}^{-1}(q) / \int_{0}^{1} F^{-1}(t)dt = y/\mu$, the entropy function becomes the Theil inequality index

\[
I_{Theil} = \int_{0}^{\infty} \frac{y}{\mu} \log \bigg( \frac{y}{\mu} \bigg) dF(y) = -H(s)
\]

Therefore, the entropy-based inequality measure increases as a person's income $y$ deviates from the mean $\mu$. This is the basic idea behind entropy-based inequality measures.

## Generalized Entropy and Decomposition (svygei, svygeidec)

Using a generalization of the information function, now defined as $g(f) = \frac{1}{\alpha-1} [ 1 - f^{\alpha - 1} ]$, the $\alpha$-class entropy is 
\[
H_\alpha(f) = \frac{1}{\alpha - 1} \bigg[ 1 - \int_{-\infty}^{\infty} f(y)^{ \alpha - 1} f(y) dy \bigg] \text{.}
\]

This relates to a class of inequality measures, the Generalized entropy indices, defined as:

\[
GE_\alpha = \frac{1}{\alpha^2 - \alpha} \int_{0}^\infty \bigg[ \bigg( \frac{y}{\mu} \bigg)^\alpha - 1 \bigg]dF(x) = - \frac{-H_\alpha(s) }{ \alpha } \text{.}
\]

The parameter $\alpha$ also has an economic interpretation: as $\alpha$ increases, the influence of top incomes upon the index increases. In some cases, this measure takes special forms, such as mean log deviation and the aforementioned Theil index.

In order to estimate it, [@biewen2003] proposed the following:

\[
GE_\alpha =
\begin{cases}
( \alpha^2 - \alpha)^{-1} \big[ U_0^{\alpha - 1} U_1^{-\alpha} U_\alpha -1 \big], & \text{if } \alpha \in \mathbb{R} \setminus \{0,1\} \\
- T_0 U_0^{-1} + \log ( U_1 / U_0 ), &\text{if } \alpha \rightarrow 0 \\
T_1 U_1^{-1} - \log ( U_1 / U_0 ), & \text{if } \alpha \rightarrow 1
\end{cases}
\]

where $U_\gamma = \sum_{i \in S} w_i \cdot y_i^\gamma$ and $T_\gamma = \sum_{i \in S} w_i \cdot y_i^\gamma \cdot \log y_i$. since those are all functions of totals, the linearization of the indices are easily achieved using the theorems described in [@deville1999].

This class also has several desirable properties, such as additive decomposition. The additive decomposition allows to compare the effects of inequality within and between population groups on the population inequality. Put simply, an additive decomposable index allows for:

\[
I_{Total} = I_{Between} + I_{Within} \text{.}
\]

---

**A replication example**

In July 2006, [@jenkins2006] presented at the North American Stata Users' Group Meetings on the stata Generalized Entropy Index command.  The example below reproduces those statistics.

Load and prepare the same data set:
```{r}
# load the convey package
library(convey)

# load the survey library
library(survey)

# load the foreign library
library(foreign)

# create a temporary file on the local disk
tf <- tempfile()

# store the location of the presentation file
presentation_zip <- "http://repec.org/nasug2006/nasug2006_jenkins.zip"

# download jenkins' presentation to the temporary file
download.file( presentation_zip , tf , mode = 'wb' )

# unzip the contents of the archive
presentation_files <- unzip( tf , exdir = tempdir() )

# load the institute for fiscal studies' 1981, 1985, and 1991 data.frame objects
x81 <- read.dta( grep( "ifs81" , presentation_files , value = TRUE ) )
x85 <- read.dta( grep( "ifs85" , presentation_files , value = TRUE ) )
x91 <- read.dta( grep( "ifs91" , presentation_files , value = TRUE ) )

# stack each of these three years of data into a single data.frame
x <- rbind( x81 , x85 , x91 )
```

Replicate the author's survey design statement from stata code..
```{code}
. * account for clustering within HHs 
. version 8: svyset [pweight = wgt], psu(hrn)
pweight is wgt
psu is hrn
construct an
```

.. into R code:


```{r}
# initiate a linearized survey design object
y <- svydesign( ~ hrn , data = x , weights = ~ wgt )

# immediately run the `convey_prep` function on the survey design
z <- convey_prep( y )
```

Replicate the author's subset statement and each of his svygei results..
```{code}
. svygei x if year == 1981
 
Warning: x has 20 values = 0. Not used in calculations

Complex survey estimates of Generalized Entropy inequality indices
 
pweight: wgt                                   Number of obs    = 9752
Strata: <one>                                  Number of strata = 1
PSU: hrn                                       Number of PSUs   = 7459
											   Population size  = 54766261
---------------------------------------------------------------------------
Index    |  Estimate   Std. Err.      z      P>|z|     [95% Conf. Interval]
---------+-----------------------------------------------------------------
GE(-1)   |  .1902062   .02474921     7.69    0.000      .1416987   .2387138
MLD      |  .1142851   .00275138    41.54    0.000      .1088925   .1196777
Theil    |  .1116923   .00226489    49.31    0.000      .1072532   .1161314
GE(2)    |   .128793   .00330774    38.94    0.000      .1223099    .135276
GE(3)    |  .1739994   .00662015    26.28    0.000      .1610242   .1869747
---------------------------------------------------------------------------
```

..using R code:

```{r}
z81 <- subset( z , year == 1981 )

svygei( ~ eybhc0 , subset( z81 , eybhc0 > 0 ) , epsilon = -1 )
svygei( ~ eybhc0 , subset( z81 , eybhc0 > 0 ) , epsilon = 0 )
svygei( ~ eybhc0 , subset( z81 , eybhc0 > 0 ) )
svygei( ~ eybhc0 , subset( z81 , eybhc0 > 0 ) , epsilon = 2 )
svygei( ~ eybhc0 , subset( z81 , eybhc0 > 0 ) , epsilon = 3 )
```	



Confirm this replication applies for subsetted objects as well.  Compare stata output..

```{code}
. svygei x if year == 1985 & x >= 1

Complex survey estimates of Generalized Entropy inequality indices
 
pweight: wgt                                   Number of obs    = 8969
Strata: <one>                                  Number of strata = 1
PSU: hrn                                       Number of PSUs   = 6950
											   Population size  = 55042871
---------------------------------------------------------------------------
Index    |  Estimate   Std. Err.      z      P>|z|     [95% Conf. Interval]
---------+-----------------------------------------------------------------
GE(-1)   |  .1602358   .00936931    17.10    0.000      .1418723   .1785993
MLD      |   .127616   .00332187    38.42    0.000      .1211052   .1341267
Theil    |  .1337177   .00406302    32.91    0.000      .1257543    .141681
GE(2)    |  .1676393   .00730057    22.96    0.000      .1533304   .1819481
GE(3)    |  .2609507   .01850689    14.10    0.000      .2246779   .2972235
---------------------------------------------------------------------------
```

..to R code:

```{r}
z85 <- subset( z , year == 1985 )

svygei( ~ eybhc0 , subset( z85 , eybhc0 > 1 ) , epsilon = -1 )
svygei( ~ eybhc0 , subset( z85 , eybhc0 > 1 ) , epsilon = 0 )
svygei( ~ eybhc0 , subset( z85 , eybhc0 > 1 ) )
svygei( ~ eybhc0 , subset( z85 , eybhc0 > 1 ) , epsilon = 2 )
svygei( ~ eybhc0 , subset( z85 , eybhc0 > 1 ) , epsilon = 3 )
```



For additional usage examples of `svygei` or `svygeidec`, type `?convey::svygei` or `?convey::svygeidec` in the R console.



## Rényi Divergence (svyrenyi)

Another measure used in areas like ecology, statistics and information theory is Rényi divergence measure. Using the formula defined in [@langel2012], the estimator can be defined as:

\[
\widehat{R}_\alpha =
\begin{cases}
\frac{1}{\alpha - 1} \log \bigg[ \widehat{N}^{\alpha - 1} \sum_{i \in S} w_i \cdot \bigg( \frac{y_k}{ \widehat{Y} } \bigg) \bigg], &\text{if } \alpha \neq 1, \\
\sum_{i \in S} \frac{w_i y_i}{ \widehat{Y}} \log \frac{\widehat{N} y_i}{\widehat{Y}}, &\text{if } \alpha = 1,
\end{cases}
\]

where $\alpha$ is a parameter with a similar economic interpretation to that of the $GE_\alpha$ index.


For additional usage examples of `svyrenyi`, type `?convey::svyrenyi` in the R console.

## J-Divergence and Decomposition (svyjdiv, svyjdivdec)

Proposed by [@rohde2016], the J-divergence measure can be seen as the sum of $GE_0$ and $GE_1$, satisfying axioms that, individually, those two indices do not. Using $U_\gamma$ and $T_\gamma$ functions defined in \ref{subsection.3.3.1}, the estimator can be defined as:

\[
\begin{aligned}
\widehat{J} &= \frac{1}{\widehat{N}} \sum_{i \in S} w_i \bigg( \frac{ y_i - \widehat{\mu} }{ \widehat{\mu} } \bigg) \log \bigg( \frac{y_i}{\widehat{\mu}} \bigg) \\
\therefore \widehat{J} &= \frac{\widehat{T}_1}{\widehat{U}_1} - \frac{ \widehat{T}_0 }{ \widehat{U}_0 }
\end{aligned}
\]

Since it is a sum of two additive decomposable measures, $J$ itself is decomposable.




For additional usage examples of `svyjdiv` or `svyjdivdec`, type `?convey::svyjdiv` or `?convey::svyjdivdec` in the R console.



## Atkinson index (svyatk)

Although the original formula was proposed in [@atkinson1970], the estimator used here comes from [@biewen2003]:

\[
\widehat{A}_\epsilon =
\begin{cases}
 1 - \widehat{U}_0^{ - \epsilon/(1 - \epsilon) } \widehat{U}_1^{ -1 } \widehat{U}_{1 - \epsilon}^{ 1/(1 - \epsilon) } , &\text{if } \epsilon \in \mathbb{R}_+ \setminus\{ 1 \} \\
1 - \widehat{U}_0 \widehat{U}_0^{-1} exp( \widehat{T}_0 \widehat{U}_0^{-1} ), &\text{if } \epsilon \rightarrow1
\end{cases}
\]

The $\epsilon$ is an inequality aversion parameter: as it approaches infinity, more weight is given to incomes in bottom of the distribution.

---

**A replication example**

In July 2006, [@jenkins2006] presented at the North American Stata Users' Group Meetings on the stata Atkinson Index command.  The example below reproduces those statistics.

Load and prepare the same data set:
```{r}
# load the convey package
library(convey)

# load the survey library
library(survey)

# load the foreign library
library(foreign)

# create a temporary file on the local disk
tf <- tempfile()

# store the location of the presentation file
presentation_zip <- "http://repec.org/nasug2006/nasug2006_jenkins.zip"

# download jenkins' presentation to the temporary file
download.file( presentation_zip , tf , mode = 'wb' )

# unzip the contents of the archive
presentation_files <- unzip( tf , exdir = tempdir() )

# load the institute for fiscal studies' 1981, 1985, and 1991 data.frame objects
x81 <- read.dta( grep( "ifs81" , presentation_files , value = TRUE ) )
x85 <- read.dta( grep( "ifs85" , presentation_files , value = TRUE ) )
x91 <- read.dta( grep( "ifs91" , presentation_files , value = TRUE ) )

# stack each of these three years of data into a single data.frame
x <- rbind( x81 , x85 , x91 )
```

Replicate the author's survey design statement from stata code..
```{code}
. * account for clustering within HHs 
. version 8: svyset [pweight = wgt], psu(hrn)
pweight is wgt
psu is hrn
construct an
```

.. into R code:


```{r}
# initiate a linearized survey design object
y <- svydesign( ~ hrn , data = x , weights = ~ wgt )

# immediately run the `convey_prep` function on the survey design
z <- convey_prep( y )
```

Replicate the author's subset statement and each of his svyatk results with stata..
```{code}
. svyatk x if year == 1981
 
Warning: x has 20 values = 0. Not used in calculations

Complex survey estimates of Atkinson inequality indices
 
pweight: wgt                                   Number of obs    = 9752
Strata: <one>                                  Number of strata = 1
PSU: hrn                                       Number of PSUs   = 7459
                                               Population size  = 54766261
---------------------------------------------------------------------------
Index    |  Estimate   Std. Err.      z      P>|z|     [95% Conf. Interval]
---------+-----------------------------------------------------------------
A(0.5)   |  .0543239   .00107583    50.49    0.000      .0522153   .0564324
A(1)     |  .1079964   .00245424    44.00    0.000      .1031862   .1128066
A(1.5)   |  .1701794   .0066943    25.42    0.000       .1570588      .1833
A(2)     |  .2755788   .02597608    10.61    0.000      .2246666    .326491
A(2.5)   |  .4992701   .06754311     7.39    0.000       .366888   .6316522
---------------------------------------------------------------------------
```

..using R code:

```{r}
z81 <- subset( z , year == 1981 )

svyatk( ~ eybhc0 , subset( z81 , eybhc0 > 0 ) , epsilon = 0.5 )
svyatk( ~ eybhc0 , subset( z81 , eybhc0 > 0 ) )
svyatk( ~ eybhc0 , subset( z81 , eybhc0 > 0 ) , epsilon = 1.5 )
svyatk( ~ eybhc0 , subset( z81 , eybhc0 > 0 ) , epsilon = 2 )
svyatk( ~ eybhc0 , subset( z81 , eybhc0 > 0 ) , epsilon = 2.5 )
```



Confirm this replication applies for subsetted objects as well, comparing stata code..
```{code}
. svyatk x if year == 1981 & x >= 1

Complex survey estimates of Atkinson inequality indices
 
pweight: wgt                                   Number of obs    = 9748
Strata: <one>                                  Number of strata = 1
PSU: hrn                                       Number of PSUs   = 7457
                                               Population size  = 54744234
---------------------------------------------------------------------------
Index    |  Estimate   Std. Err.      z      P>|z|     [95% Conf. Interval]
---------+-----------------------------------------------------------------
A(0.5)   |  .0540059   .00105011    51.43    0.000      .0519477   .0560641
A(1)     |  .1066082   .00223318    47.74    0.000      .1022313   .1109852
A(1.5)   |  .1638299   .00483069    33.91    0.000       .154362   .1732979
A(2)     |  .2443206   .01425258    17.14    0.000      .2163861   .2722552
A(2.5)   |   .394787   .04155221     9.50    0.000      .3133461   .4762278
---------------------------------------------------------------------------
```

..to R code:

```{r}
z81_two <- subset( z , year == 1981 & eybhc0 > 1 )

svyatk( ~ eybhc0 , z81_two , epsilon = 0.5 )
svyatk( ~ eybhc0 , z81_two )
svyatk( ~ eybhc0 , z81_two , epsilon = 1.5 )
svyatk( ~ eybhc0 , z81_two , epsilon = 2 )
svyatk( ~ eybhc0 , z81_two , epsilon = 2.5 )
```




For additional usage examples of `svyatk`, type `?convey::svyatk` in the R console.

<!--chapter:end:02-inequality.Rmd-->

# Wellbeing Measures  {#wellbeing}

djalmapessoa_look do any of the other functions need to be moved to this wellbeing chapter?


## The Gender Pay Gap (svygpg)



For additional usage examples of `svygpg`, type `?convey::svygpg` in the R console.


here are the references


[@osier2009] and [@deville1999]



## Quintile Share Ratio (svyqsr)



For additional usage examples of `svyqsr`, type `?convey::svyqsr` in the R console.


here are the references

[@osier2009] and [@deville1999]


<!--chapter:end:03-wellbeing.Rmd-->

---
output:
  pdf_document: default
  html_document: default
---
# Multidimensional Indices {#multidimensional}

Inequality and poverty can be seen as multidimensional concepts, combining several livelihood characteristics. Usual approaches take into account income, housing, sanitation, etc. 

In order to transform these different measures from into meaningful numbers, economic theory builds on the idea of utility functions. Utility is a measure of well-being, assigning a "well-being score" to a vector of characteristics. Depending on the utility function, the analyst may allow for substitutions among characteristics: for instance, someone with a slightly lower income, but with access to sanitation, can have a higher wellbeing than someone with a higher income, but without access to sanitation. This depends on the set of weights given to the set of attributes.

Most measures below follow from this kind of two-step procedure: (1) estimating individual scores from an individual's set of characteristics; then (2) aggregating those individual scores into a single measure for the population.

The following section will present a measure of multidimensional poverty and a measure of multidimensional inequality, describing the main aspects of the theory and estimation procedures of each.

## Alkire-Foster Class and Decomposition (svyafc, svyafcdec)

This class of measures are defined in [@alkire2011], using what is called the "dual cutoff" approach. This method applies a cutoffs to define dimensional deprivations and another cutoff for multidimensional deprivation. 

To analyze a population of $n$ individuals across $d$ achievement dimensions, the first step of the method is applying a FGT-like transformation to each dimension, defined as

\[
g_{ij}^\alpha = \bigg( \frac{ z_j - x_{ij} }{ z_j } \bigg)^{\alpha}
\]

where $i$ is an observation index, $j$ is a dimension index and $\alpha$ is an exponent weighting the deprivation intensity. If $\alpha=0$, then $g_{ij}^0$ becomes a binary variable, assuming value $1$ if person $i$ is deprived in dimension $j$ and $0$ otherwise. The $n \times d$ matrix $G^\alpha$ will be referred to as *deprivation matrix*.

Each dimension receives a weight $w_j$, so that the weighted sum of multidimensional deprivation is the matrix multiplication of $G^\alpha$ by the $j \times 1$ vector $W = [w_j]$. The $n \times 1$ vector $C^\alpha = [c^\alpha_i]$ is the weighted sum of dimensional deprivation scores, i.e.,

\[
c^\alpha_{i} = \sum_{j \in d} w_j g_{ij}^\alpha
\]

The second cutoff is defining those considered to be multidimensionally poor. Assuming that $\sum_{j \in d} w_j = 1$, the multidimensional cutoff $k$ belongs to the interval $(0,1]$. If $c^0_{i} \geqslant k$, then this person is considered multidimensionally poor. The *censored vector of deprivation sums* $C^\alpha(k)$ is defined as

\[
C^\alpha (k) = \bigg[ c_{ij}^\alpha \cdot \delta \big( c_{ij}^0 \geqslant k \big) \bigg] \text{,}
\]

where $\delta(A)$ is an indicator function, taking value $1$ if condition $A$ is true and $0$ otherwise. If $k \geqslant \min{ w_j }$, this is called the "union approach", where a person is considered poor if she is poor in at least one dimension. On the other extreme, the "intersection approach" happens when $k = 1$, meaning that a person is considered poor if she is poor in all dimensions.

The average of vector $C^0 (k)$ returns the multidimensional headcount ratio. For the multidimensional FGT class, a general measure can be defined as

\[
M^\alpha = \frac{1}{n} \sum_{i \in n} \sum_{j \in d} w_j g_{ij}^{\alpha}(k) \text{, } \alpha \geq 0 \text{,}
\]

where $g_{ij}^{\alpha}(k) = g_{ij}^\alpha \cdot \delta \big( c^0_i \geqslant k \big)$.

For inferential purposes, since this variable is actually the average of scores $\sum_{j \in d} w_j g_{ij}^{\alpha}(k)$, the linearization is straightforward.

The Alkire-Foster index is both dimensional and subgroup decomposable. This way, it is possible to analyze how much each dimension or group contribute to the general result. The overall poverty measure can be seen as the weighted sum of each group's poverty measure, as in the formula below:

\[
M^\alpha = \sum_{l \in L} \frac{ n_l }{ n } M^\alpha_{l}
\]

where $l$ is one of $L$ groups.

Also, the overall poverty index can be expressed across dimensions as
\[
M^\alpha = \sum_{j \in d} w_j \bigg[ \frac{1}{n} \sum_{i \in n} g_{ij}^\alpha (k) \bigg] \text{.}
\]

Since those functions are linear combinations of ratios and totals, it is also possible to calculate standard errors for such measures.

---

**A replication example**

In November 2015, Christopher Jindra presented at the Oxford Poverty and Human Development Initiative on the Alkire-Foster multidimensional poverty measure. His presentation can be viewed [here](http://www.ophi.org.uk/wp-content/uploads/Jindra_151109_OPHISeminar.pdf). The example below reproduces those statistics.

Load and prepare the same data set:
```{r message=FALSE, warning=FALSE}
# load the convey package
library(convey)

# load the survey library
library(survey)

# load the stata-style webuse library
library(webuse)

# load the same microdata set used by Jindra in his presentation
webuse("nlsw88")

# coerce that `tbl_df` to a standard R `data.frame`
nlsw88 <- data.frame( nlsw88 )

# create a `collgrad` column
nlsw88$collgrad <-
    factor( 
        as.numeric( nlsw88$collgrad ) , 
        label = c( 'not college grad' , 'college grad' ) , 
        ordered = TRUE 
      )

# coerce `married` column to factor
nlsw88$married <- 
    factor( 
        nlsw88$married , 
        levels = 0:1 , 
        labels = c( "single" , "married" ) 
    )

# initiate a linearized survey design object
des_nlsw88 <- svydesign( ids = ~1 , data = nlsw88 )

# immediately run the `convey_prep` function on the survey design
des_nlsw88 <- convey_prep(des_nlsw88)
```


Replicate PDF page 9
```{r message=FALSE, warning=FALSE}
page_nine <-
  svyafc(
    ~ wage + collgrad + hours , 
    design = des_nlsw88 , 
    cutoffs = list( 4, 'college grad' , 26 ) , 
    k = 1/3 , g = 0 , 
    na.rm = TRUE
  )

# MO and seMO
print( page_nine )

# H seH and A seA
print( attr( page_nine , "extra" ) )
```


Replicate PDF page 10
```{r message=FALSE, warning=FALSE}
page_ten <- NULL

# loop through every poverty cutoff `k`
for( ks in seq( 0.1 , 1 , .1 ) ){
	
	this_ks <-
	    svyafc(
	        ~ wage + collgrad + hours , 
	        design = des_nlsw88 , 
	        cutoffs = list( 4 , 'college grad' , 26 ) , 
	        k = ks , 
	        g = 0 , 
	        na.rm = TRUE 
	       )
	
	page_ten <-
	    rbind(
	        page_ten ,
	        data.frame( 
	            k = ks , 
	            MO = coef( this_ks ) ,
	            seMO = SE( this_ks ) ,
	            H = attr( this_ks , "extra" )[ 1 , 1 ] ,
	            seH = attr( this_ks , "extra" )[ 1 , 2 ] ,
	            A = attr( this_ks , "extra" )[ 2 , 1 ] ,
	            seA = attr( this_ks , "extra" )[ 2 , 2 ]
          )
	    )
	
}
```

```{r echo = FALSE}
knitr::kable(
  page_ten , caption = 'PDF Page 10 Replication',
  booktabs = TRUE
)
```


Replicate PDF page 13
```{r}
page_thirteen <- NULL

# loop through every poverty cutoff `k`
for( ks in c( 0.5 , 0.75 , 1 ) ){
	
	this_ks <-
	    svyafc(
        ~ wage + collgrad + hours , 
        design = des_nlsw88 , 
        cutoffs = list( 4, 'college grad' , 26 ) , 
        k = ks , 
        g = 0 , 
        dimw = c( 0.5 , 0.25 , 0.25 ) ,
        na.rm = TRUE
      )
	
	page_thirteen <-
	    rbind(
	        page_thirteen ,
	        data.frame( 
	            k = ks , 
	            MO = coef( this_ks ) ,
	            seMO = SE( this_ks ) ,
	            H = attr( this_ks , "extra" )[ 1 , 1 ] ,
	            seH = attr( this_ks , "extra" )[ 1 , 2 ] ,
	            A = attr( this_ks , "extra" )[ 2 , 1 ] ,
	            seA = attr( this_ks , "extra" )[ 2 , 2 ]
          )
	    )
}
```

```{r echo = FALSE}
knitr::kable(
  page_thirteen , caption = 'PDF Page 13 Replication',
  booktabs = TRUE
)
```

Replicate PDF page 16
```{r}
page_sixteen <- NULL

# loop through every alpha value `g`
for( gs in 0:3 ){
	
	this_gs <-
	    svyafc(
        ~ wage + collgrad + hours , 
        design = des_nlsw88 , 
        cutoffs = list( 4, 'college grad' , 26 ) , 
        k = 1/3 , 
        g = gs , 
        na.rm = TRUE
      )
	
	page_sixteen <-
	    rbind(
	        page_sixteen ,
	        data.frame( 
	            g = gs , 
	            MO = coef( this_gs ) ,
	            seMO = SE( this_gs ) 
          )
	    )
}
```


```{r echo = FALSE}
knitr::kable(
  page_sixteen , caption = 'PDF Page 16 Replication',
  booktabs = TRUE
)
```





Replicate k=1/3 rows of PDF page 17 and 19
```{r}
svyafcdec(
    ~ wage + collgrad + hours , 
    design = des_nlsw88 , 
    cutoffs = list( 4 , 'college grad' , 26 ) , 
    k = 1/3 , 
    g = 0 ,
    na.rm = TRUE
)
```



Replicate PDF pages 21 and 22
```{r}
svyafcdec(
    ~ wage + collgrad + hours , 
    subgroup = ~married , 
    design = des_nlsw88 , 
    cutoffs = list( 4 , 'college grad' , 26 ) , 
    k = 1/3 , 
    g = 0 ,
    na.rm = TRUE
)
```


For additional usage examples of `svyafc` or `svyafcdec`, type `?convey::svyafc` or `?convey::svyafcdec` in the R console.


[@alkire2011] and [@alkire2015] and [@pacifico2016]

## Bourguignon-Chakravarty (2003) multidimensional poverty class



## Bourguignon (1999) inequality class (svybmi)


For additional usage examples of `svybmi`, type `?convey::svybmi` in the R console.


[@bourguignon1999] and [@lugo2007]

<!--chapter:end:04-multidimensional.Rmd-->

